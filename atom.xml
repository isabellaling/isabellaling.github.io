<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>荼荼小蘼</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-18T14:23:53.557Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Isabella Ling</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>趣谈网络协议</title>
    <link href="http://yoursite.com/2019/09/18/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/09/18/趣谈网络协议/</id>
    <published>2019-09-18T14:23:50.000Z</published>
    <updated>2019-09-18T14:23:53.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h1><p>疑问1. 局域网内部如果找到匹配的ip？<br>ARP</p><p>疑问2. TCP发送确认包的粒度？</p><h1 id="为什么要学习网络协议？"><a href="#为什么要学习网络协议？" class="headerlink" title="为什么要学习网络协议？"></a>为什么要学习网络协议？</h1><p>语言是双方沟通的前提，然后才能达成协议。语言其实也是一种协议。<br>协议三要素：语法、语义、顺序。<br>网络协议可以使一大片机器互相协作，共同完成一件事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一节&quot;&gt;&lt;a href=&quot;#第一节&quot; class=&quot;headerlink&quot; title=&quot;第一节&quot;&gt;&lt;/a&gt;第一节&lt;/h1&gt;&lt;p&gt;疑问1. 局域网内部如果找到匹配的ip？&lt;br&gt;ARP&lt;/p&gt;
&lt;p&gt;疑问2. TCP发送确认包的粒度？&lt;/p&gt;
&lt;h1 id=&quot;为
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="极客时间" scheme="http://yoursite.com/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>重生之将门毒后</title>
    <link href="http://yoursite.com/2019/09/18/%E9%87%8D%E7%94%9F%E4%B9%8B%E5%B0%86%E9%97%A8%E6%AF%92%E5%90%8E/"/>
    <id>http://yoursite.com/2019/09/18/重生之将门毒后/</id>
    <published>2019-09-18T06:00:00.000Z</published>
    <updated>2019-09-18T14:29:59.325Z</updated>
    
    <content type="html"><![CDATA[<p>这本书其实文笔一般，文字并不优美，逻辑也经常怪怪的，甚至还有很多错别字…唯一的优势就是剧情还可以，然后男主的人设比较吸引人。</p><p>至于女主，嗯，上辈子很傻，属于那种被人卖了还帮别人数钱的那挂。重生之后，幡然悔悟，开挂一般手刃仇人，守护自己的家人，最后邂逅男主，功德圆满。</p><p>男主嘛，小时候因为国家动乱被自己老妈送到敌国，长大之后诈尸（抱歉，是炸死）后恢复身份，最后统一诸国，黄袍加身，emmm。</p><p>里面还喜欢女主老爸老妈，老哥和冯安宁，高阳罗谭，谢行止显徳皇后这几对，虽然并不全是圆满结局，哎。</p><p>最后吐槽一句，这本书真tm长呀……看了我好几天，emmmm，我这看书一定要看完的毛病到底什么时候能改掉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这本书其实文笔一般，文字并不优美，逻辑也经常怪怪的，甚至还有很多错别字…唯一的优势就是剧情还可以，然后男主的人设比较吸引人。&lt;/p&gt;
&lt;p&gt;至于女主，嗯，上辈子很傻，属于那种被人卖了还帮别人数钱的那挂。重生之后，幡然悔悟，开挂一般手刃仇人，守护自己的家人，最后邂逅男主，功德
      
    
    </summary>
    
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="书评" scheme="http://yoursite.com/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>代理模式-远程代理</title>
    <link href="http://yoursite.com/2019/09/18/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/18/代理模式-远程代理/</id>
    <published>2019-09-17T16:02:37.000Z</published>
    <updated>2019-09-18T14:27:13.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目之间通讯，我们常用的是通过http协议。</p><p>java提供了rmi方式，使服务可以调用远程服务的java类，就像使用本地服务一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目之间通讯，我们常用的是通过http协议。&lt;/p&gt;
&lt;p&gt;java提供了rmi方式，使服务可以调用远程服务的java类，就像使用本地服务一
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="代理模式" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>哈利波特与阿兹卡班的囚徒</title>
    <link href="http://yoursite.com/2019/09/11/%E5%93%88%E5%88%A9%E6%B3%A2%E7%89%B9%E4%B8%8E%E9%98%BF%E5%85%B9%E5%8D%A1%E7%8F%AD%E7%9A%84%E5%9B%9A%E5%BE%92/"/>
    <id>http://yoursite.com/2019/09/11/哈利波特与阿兹卡班的囚徒/</id>
    <published>2019-09-11T01:05:00.000Z</published>
    <updated>2019-09-18T14:27:53.623Z</updated>
    
    <content type="html"><![CDATA[<p>哇！太棒了，终于看完了哈利波特第三部，感觉自己好酷！</p><p>电影里面，我最喜欢的就是第三部，因为在这一部里面，哈利终于有了家人，一个爱他的godfather，真好，个人认为最温暖的一部。</p><p>原著和电影其实蛮多不一样的，原著有很多细节，比如说，Lupin不是生来就是狼人，是因为小时候被狼人咬过。然后因为狼人每个月圆之夜都会变身，然后就会六亲不认到处咬人，所以lupin本身是没资格上Hogwarts的，但是邓布利多好心，给了他机会。</p><p>不过也因为狼人变身很危险，所以做了很多措施，比如whomping Willow就是在Lupin来Hogwarts的那一年种下的，whomping Willow打人也是为了防止大家靠近过道， whomping willow下通往shirkinghouse的过道也是为他而建的。每次lupin变身，就会从这个过道里去到xxhouse，然后大家都以为的闹鬼，其实是因为lupin变身太痛苦的尖叫。</p><p>还有还有，james lupin Sirius pettigrew是好朋友，他们三个发现lupin是狼人之后，才特意去学习了很危险的animagous，为了能一起变身陪lupin。animagous魔法很难学习，稍有不慎就走火入魔，所以魔法部对于这个是有严格规定和登记的。登记在案的animagous不超过十个？他们三个是偷偷学的，没登记，james和sirius可以说是很厉害了，pettigrew也是在他们两个的帮助下才学会的。</p><p>然后snape一直记恨他们四个，也一直在想办法整他们，snape知道lupin个月都会失踪，有次被他跟踪到whomping willow，但是苦于过不去。Sirius就想整整他，告诉了他通过打人柳的方法，想让他吃吃变身狼人lupin的苦头。但是James觉得不妥，于是悬崖勒马拉回了Snape，不然就Snape就gg了。</p><p>然后lily和james的secret keeper本来应该是sirious，但是sirious因为相信pettygrew，劝lily他们把secret keeper改成pettygrew，这样大家都以为是sirious，没人会怀疑到小小只的pettygrew上，Lily他们会更安全，没想到pettygrew会背叛。</p><p>还有啥，patronous charm是高阶魔法，很难学会，Harry也学了很久，而且一开始也是学艺不精，只是后来为了救Sirious自己和赫敏，才爆发了出来。（电影中这点没有体现，看电影的时候哈利没几下就学会了，导致当时我对这个魔法很难学这个点真的很怀疑。。</p><p>还有什么呢，有些点子是哈利想出来的，但是电影中把这些点给了赫敏，所以才有大家觉得的哈利这么蠢怎么会是救世主，其实不是这样的，看原著你会觉得哈利也很厉害，只是赫敏更努力。</p><p>关于回到过去之后，不能让别人和自己看到自己的这个点，原著讲的更清楚。如果在正常情况下，一个人看到另一个自己，要么以为自己疯了，要么就会觉得那是黑魔法，所以会有很多自己杀掉未来/过去的自己的惨案。还有就是，time turner这个东东，是麦格教授向魔法部写了很多申请，并说明赫敏是年纪里最优秀的学生，才能通过的。而且前提是，赫敏只能用于学业，且不能告诉任何人。</p><p>原著里面，赫敏和罗恩哈利因为scabbers的事情闹得很僵，很僵很僵的那种，几乎要到绝交的地步。firebolt是Sirius很早就送给哈利的，那时哈利还不知道真相，赫敏猜到了可能是Sirus送他的，担心firebolt可能被下了咒，赫敏就向麦格教授告发了这件事，firebolt也因此被缴。这件事之后，赫敏和罗恩哈利的关系更僵了。</p><p>直到比赛前夕，firebolt才归还给了哈利，哈利也因此赢得了比赛。</p><p>赫敏和罗恩哈利和好是因为buckbeak被叛了死刑，他们决心要一起帮助翻案，尽管案子没翻成功，最后buckbeak还是获救了，开心。</p><p>啊呀，还有一个点，cho竟然是revenclaw的seeker，这简直是大发现好吗！！！</p><p>书中的最后，Sirius给哈利写了信，信上附上了作为监护人的Sirius，同意哈利去Hogsmead，所以下一季的时候哈利才可以无所忌惮的去Hogmead，真好。</p><p>Last but not the least，I really love Harry Potter Siries.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;哇！太棒了，终于看完了哈利波特第三部，感觉自己好酷！&lt;/p&gt;
&lt;p&gt;电影里面，我最喜欢的就是第三部，因为在这一部里面，哈利终于有了家人，一个爱他的godfather，真好，个人认为最温暖的一部。&lt;/p&gt;
&lt;p&gt;原著和电影其实蛮多不一样的，原著有很多细节，比如说，Lupin不
      
    
    </summary>
    
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="书评" scheme="http://yoursite.com/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>时间管理及效率</title>
    <link href="http://yoursite.com/2019/09/07/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%8F%8A%E6%95%88%E7%8E%87/"/>
    <id>http://yoursite.com/2019/09/07/时间管理及效率/</id>
    <published>2019-09-07T07:13:49.000Z</published>
    <updated>2019-09-07T07:14:43.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间块app"><a href="#时间块app" class="headerlink" title="时间块app"></a>时间块app</h1><h2 id="事件类别，事件内容，印章如何区分使用"><a href="#事件类别，事件内容，印章如何区分使用" class="headerlink" title="事件类别，事件内容，印章如何区分使用"></a>事件类别，事件内容，印章如何区分使用</h2><p>时间块app里，可以分别通过事件类别、时间内容来查看日/周/月的时间花销。</p><p>先把日常生活中的时间大致分为几块，如学习、生活、娱乐、运动，这个大的分类可以用<strong>事件类别</strong>来表示。</p><p>拿”生活”来举例。<br>“生活”分类中，有需要统计时间的，如睡觉，可用<strong>事件内容</strong>表示。<br>以及不需统计时间的，如刷牙洗脸、买菜路上，如果不在意这段时间做了什么，直接标记为事件类别”生活”即可，如果想要记录的详细点，可以先加备注，然后保存为印章，方便下次进行快捷添加。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间块app&quot;&gt;&lt;a href=&quot;#时间块app&quot; class=&quot;headerlink&quot; title=&quot;时间块app&quot;&gt;&lt;/a&gt;时间块app&lt;/h1&gt;&lt;h2 id=&quot;事件类别，事件内容，印章如何区分使用&quot;&gt;&lt;a href=&quot;#事件类别，事件内容，印章如何区分使用&quot;
      
    
    </summary>
    
    
    
      <category term="时间管理" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>摘录</title>
    <link href="http://yoursite.com/2019/09/07/%E6%91%98%E5%BD%95/"/>
    <id>http://yoursite.com/2019/09/07/摘录/</id>
    <published>2019-09-07T05:36:07.000Z</published>
    <updated>2019-09-18T14:27:48.555Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在知乎上看到一句话，有被感动到。</p><blockquote><p>你必须很努力才能看起来毫不费力。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天在知乎上看到一句话，有被感动到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你必须很努力才能看起来毫不费力。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
    
      <category term="摘录" scheme="http://yoursite.com/tags/%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://yoursite.com/2019/09/04/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/09/04/Linux常用命令/</id>
    <published>2019-09-04T14:00:00.000Z</published>
    <updated>2019-09-18T14:28:09.559Z</updated>
    
    <content type="html"><![CDATA[<p>本文收录了Linux系统中的常用命令，便于自己查阅，会不定期更新哈。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建空文件</span></span><br><span class="line">touch filename; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line">cp <span class="built_in">source</span> destination; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接文件</span></span><br><span class="line">ln filename link_filename; <span class="comment"># 相当于文件的快捷方式，删除链接文件不会影响远文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重命名文件</span></span><br><span class="line">mv oldname newname; <span class="comment"># 亦用于移动文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">rm -rf filename; <span class="comment"># -r递归删除该目录下包含的子目录中的文件, -f强制删除文件，不做提示</span></span><br><span class="line">rm -i filename; <span class="comment"># -i提示是否真的要删除文件，删除敏感文件时建议使用这个参数，避免误删</span></span><br></pre></td></tr></table></figure><h2 id="处理目录"><a href="#处理目录" class="headerlink" title="处理目录"></a>处理目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir dirName; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">rmdir dirName; <span class="comment"># 只能删除空目录</span></span><br><span class="line">rm -r dirName; <span class="comment"># 递归删除目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="built_in">cd</span> destination; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件和目录列表</span></span><br><span class="line">ls -a; <span class="comment"># -a显示所有文件，包括隐藏文件</span></span><br><span class="line">ls -l; <span class="comment"># -l显示长列表，包含了目录中每个文件的更多相关信息</span></span><br><span class="line">ls -R; <span class="comment"># -R递归显示当前目录下包含的子目录中的文件</span></span><br><span class="line">ls -l my*; <span class="comment"># 显示当前目录下，以my开头的文件/文件夹</span></span><br></pre></td></tr></table></figure><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件类型</span></span><br><span class="line">file filename; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">cat [option] filename; <span class="comment"># -n显示行号；-b只给有文本的行加上行号；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页显示文件内容</span></span><br><span class="line">more filename; <span class="comment"># 可以翻页，但只能向后翻页</span></span><br><span class="line">less filename; <span class="comment"># 可以翻页，且支持向前/向后翻页</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件最后几行的内容</span></span><br><span class="line">tail [option] filename; <span class="comment"># 默认显示最后10行，可以通过"-n 20"或者“-20”指定要看的行数。</span></span><br><span class="line"><span class="comment"># 显示文件开头几行的内容</span></span><br><span class="line">head [option] filename; <span class="comment"># 默认显示开头10行，可以通过"-n 20"或者“-20”指定要看的行数。</span></span><br></pre></td></tr></table></figure><h2 id="处理文件数据"><a href="#处理文件数据" class="headerlink" title="处理文件数据"></a>处理文件数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据过滤</span></span><br><span class="line"><span class="comment"># grep用于在大文件中找到匹配的数据，以行为单位</span></span><br><span class="line">grep [option] [pattern] [file]</span><br><span class="line">grep abc file1; <span class="comment"># 在file1中找到包含"abc"的行</span></span><br><span class="line">grep -n abc file1; <span class="comment"># -n显示匹配行所在的行号</span></span><br><span class="line">grep -c abc file1; <span class="comment"># 显示一共有多少行包含了abc</span></span><br><span class="line">grep -e a -e b file1; <span class="comment"># 在file1中找到包含"a"或者"b"的行。-e用于指定多个匹配模式。</span></span><br><span class="line">grep [ab] file1; <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据排序</span></span><br><span class="line">sort -n file1; <span class="comment"># 把file1的文件内容，以行为单位，按数值排序。</span></span><br><span class="line">du -sh | sort -nr; <span class="comment"># 当前目录下，按文件占用空间倒序排序，方便查看哪个文件占用空间最多。</span></span><br></pre></td></tr></table></figure><h2 id="压缩和归档"><a href="#压缩和归档" class="headerlink" title="压缩和归档"></a>压缩和归档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩单个文件</span></span><br><span class="line">gzip file1; <span class="comment"># 压缩file1, 得到file1.gz</span></span><br><span class="line">gzip file*; <span class="comment"># 压缩当前目录下，所有以file打头的文件，得到file1.gz,file2.gz,file3.gz,...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 归档，压缩多个文件</span></span><br><span class="line">tar -cvf test.rar /test1 /test2; <span class="comment"># 把test1目录和test2目录，归档到test.rar</span></span><br><span class="line"><span class="comment"># 列出归档文件的内容</span></span><br><span class="line">tar -tf test.rar;</span><br><span class="line"><span class="comment"># 提取归档文件的内容，即解压</span></span><br><span class="line">tar -xvf test.rar;</span><br><span class="line"><span class="comment"># -c创建一个新的归档文件；-v在处理文件时显示文件；-f 与-c一起时用于指定归档文件名，与-x一起时用于指定待提取的归档文件名。</span></span><br></pre></td></tr></table></figure><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监测进程</span></span><br><span class="line">ps -ef; <span class="comment">#-e显示所有进程，-f显示更多信息</span></span><br><span class="line">ps -ef | grep java; <span class="comment"># 查看java进程id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实时监测进程</span></span><br><span class="line">top; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 pid; <span class="comment"># 通过pid删除进程</span></span><br><span class="line">killall http*; <span class="comment"># 通过通配符匹配进程名称进行删除</span></span><br></pre></td></tr></table></figure><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载磁盘</span></span><br><span class="line">mount; <span class="comment"># 输出所有挂载磁盘</span></span><br><span class="line">mount -t <span class="built_in">type</span> device directory; <span class="comment"># 挂载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载磁盘</span></span><br><span class="line">umount [device|directory]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看磁盘使用情况</span></span><br><span class="line">df -h;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看某个目录的使用情况</span></span><br><span class="line">du;</span><br></pre></td></tr></table></figure><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有全局变量</span></span><br><span class="line">printenv;</span><br><span class="line">env;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个全局变量，env不支持</span></span><br><span class="line">printenv HOME;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有环境变量，包括全局变量和局部变量。Linux并没有一个可以只显示局部环境变量的命令</span></span><br><span class="line"><span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置局部用户定义变量</span></span><br><span class="line">my_variable=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$my_variable</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局环境变量</span></span><br><span class="line"><span class="built_in">export</span> my_variable; <span class="comment"># 只在当前会话有效，关闭会话后失效。如果想永久生效，可把这句命令拷贝到linux启动脚本中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除环境变量</span></span><br><span class="line"><span class="built_in">unset</span> my_variable;</span><br></pre></td></tr></table></figure><h1 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h1><h2 id="近期使用的命令列表"><a href="#近期使用的命令列表" class="headerlink" title="近期使用的命令列表"></a>近期使用的命令列表</h2><p>bash shell会跟踪你用过的命令，并将其保存在.bash_history中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看最近用过的命令列表</span></span><br><span class="line"><span class="built_in">history</span>; <span class="comment"># 输出近期使用的命令列表，每个命令按执行时间顺序，带有行号。</span></span><br><span class="line"><span class="built_in">history</span> | tail -50; <span class="comment"># 查看最近用过的50条命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次执行最近的一条命令</span></span><br><span class="line">!!; <span class="comment"># 如刚执行了ls，此时再输入"!!"，会把ls再执行一遍</span></span><br><span class="line">!40; <span class="comment"># 执行第40条历史命令。</span></span><br></pre></td></tr></table></figure><p>最后，如果想不起来某个命令怎么用了，man一下看下文档就好啦～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文收录了Linux系统中的常用命令，便于自己查阅，会不定期更新哈。&lt;/p&gt;
&lt;h1 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h1&gt;&lt;h2 id=&quot;处理文件&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring实战-AOP</title>
    <link href="http://yoursite.com/2019/09/04/Spring%E5%AE%9E%E6%88%98-AOP/"/>
    <id>http://yoursite.com/2019/09/04/Spring实战-AOP/</id>
    <published>2019-09-04T01:00:00.000Z</published>
    <updated>2019-09-18T14:28:52.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><p>@todo 通俗的介绍一下AOP术语</p><p>AOP，Aspect Oriented Programming，面向切面编程。</p><p>横切关注点，日志安全等功能，不影响现有业务逻辑，解耦，业务代码，</p><p>如日志、事务、安全等功能，从概念上是与应用的业务逻辑无关的，基于解耦的设计理念，实际开发过程中，这些代码应该独立与其他业务逻辑代码之外。</p><p>看个例子，在系统中加入日志功能，如何设计。</p><p>侵入式，直接写入业务代码。不合理，紧耦合，且日志不是业务逻辑的一部分。</p><p>使用代理类将业务类包裹一层，然后加入日志功能。合理，但是可能需要手写很多很多个代理，且不好维护。</p><p>有人已经解决了这个问题，那就是面向切面编程，让生成代理这一步自动化。</p><p>定义横切关注点的位置、定义横切后需要做什么事情。</p><p>回顾一下动态代理。</p><h1 id="什么是aop，与oop-pop有何不同？"><a href="#什么是aop，与oop-pop有何不同？" class="headerlink" title="什么是aop，与oop/pop有何不同？"></a>什么是aop，与oop/pop有何不同？</h1><p>讲个故事，面向过程是怎么发展到面向对象和面向切面的？</p><p>面向过程、面向对象、面向切面，分别描述的是开发过程中三个不同的切入方向。</p><p>面向过程，切入点在于事情是怎么一步一步完成的。</p><p>面向对象，是面向过程的升级，把事物抽象成对象，事物的行为作为对象的方法，事物的状态作为对象的属性，然后通过组装相关对象的行为，实现某种业务逻辑，这也比较符合人类的思考习惯。</p><p>面向切面，是对传统OOP方式的补充。刚才说到，面向对象在设计对象时，对象中最好只有本对象业务相关的代码，但是在实际程序开发过程中，不可避免的，有时候需要给对象添加一些与该对象没太大关系的代码，如日志、事务等等，如果直接把这些代码添加到对象中，显然违背了面向对象的原则，紧耦合，且如果有一天，不需要这些功能了，又得重新修改对象的代码，十分不合理。最好的方式是，把对象包装一层，即静态代理，然后在代理中添加这些业务无关的代码。<br>这时候，就有一个问题了，如果仅仅只是添加一个代理，那无伤大雅，但实际开发中，如日志功能，几乎是每个类都需要支撑的，这就导致程序需要添加多个代理类，这非常不易于维护。怎么办呢？于是开发者们想出了一个办法，动态代理。</p><p>去看下代理模式！</p><p>开发过程中，有许多功能是贯穿整个系统的，如日志、安全等，每个类都需要这些功能。但如果为了引入这些功能就去修改业务逻辑代码，显然是不合适的，也违背了类的设计原则-松耦合。</p><p>面向对象编程时，对象里面包含的最好仅仅是本对象相关的代码，有时我们需要引入一些业务无关的</p><p>举个例子，怎么把大象放进冰箱里？</p><h1 id="AOP框架对比"><a href="#AOP框架对比" class="headerlink" title="AOP框架对比"></a>AOP框架对比</h1><p>目前我只知道两个AOP框架，AspectJ和Spring AOP。<br>Spring AOP在很多方面借鉴了AspectJ项目。Spring AOP只支持方法的切点。AspectJ切点的力度比较细，可以支持到构造方法和成员变量的</p><h1 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h1><h1 id="创建切面"><a href="#创建切面" class="headerlink" title="创建切面"></a>创建切面</h1><p>Spring提供了两种方式创建，使用注解，或者通过xml配置。</p><h2 id="启用AspectJ自动代理，并将切面类声明为bean"><a href="#启用AspectJ自动代理，并将切面类声明为bean" class="headerlink" title="启用AspectJ自动代理，并将切面类声明为bean"></a>启用AspectJ自动代理，并将切面类声明为bean</h2><p>JavaConfig方式，在配置类的类级别上，使用@EnableAspectJAutoProxy注解启用自动代理功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ttxm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XConfig</span></span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XLogger <span class="title">xLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> XLogger();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>亦可选择XML方式，使用Spring aop命名空间中的<a href="aop:aspectj-autoproxy" target="_blank" rel="noopener">aop:aspectj-autoproxy</a>元素.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.ttxm"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.ttxm.XLogger"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="声明前置-后置通知"><a href="#声明前置-后置通知" class="headerlink" title="声明前置/后置通知"></a>声明前置/后置通知</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ttxm;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(** concert.Performance.perform(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logBegin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterThrowing</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h2><h2 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h2><h2 id="通过切面引入新功能"><a href="#通过切面引入新功能" class="headerlink" title="通过切面引入新功能"></a>通过切面引入新功能</h2><h1 id="注入AspectJ"><a href="#注入AspectJ" class="headerlink" title="注入AspectJ"></a>注入AspectJ</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是AOP&quot;&gt;&lt;a href=&quot;#什么是AOP&quot; class=&quot;headerlink&quot; title=&quot;什么是AOP&quot;&gt;&lt;/a&gt;什么是AOP&lt;/h1&gt;&lt;p&gt;@todo 通俗的介绍一下AOP术语&lt;/p&gt;
&lt;p&gt;AOP，Aspect Oriented Programm
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="代理模式" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring实战-DI</title>
    <link href="http://yoursite.com/2019/08/26/Spring%E5%AE%9E%E6%88%98-DI/"/>
    <id>http://yoursite.com/2019/08/26/Spring实战-DI/</id>
    <published>2019-08-26T01:12:05.000Z</published>
    <updated>2019-09-18T14:29:16.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-DI是什么？"><a href="#Spring-DI是什么？" class="headerlink" title="Spring DI是什么？"></a>Spring DI是什么？</h1><p>DI，Dependency Injection，依赖注入，是Spring的两大特性之一，主要描述的是如何组装类。</p><h1 id="为什么需要依赖注入？"><a href="#为什么需要依赖注入？" class="headerlink" title="为什么需要依赖注入？"></a>为什么需要依赖注入？</h1><p>我们都知道，类之间是存在依赖关系的，而且这种关系往往不简单。就比如说汽车有四个轮子，轮子由外层的轮胎和中间的轴承组成，换成编程语言就是，汽车依赖于轮子，轮子依赖于轮胎和轴承。<br>那么，当我们需要一个汽车实例时，得先new一个轮子，在此之前还得new一个轮胎和轴承。这个过程也叫类的组装（叫装配也行，随你），是不是觉得很繁琐？要知道，现实中碰到的类可能比这个要复杂得多。</p><p>所以呢，聪明的Spring就想到了，能不能有一种更简单的方式来组装类呢？<br>还真让他想到了，只需要简单的配置，就可以让这个过程自动化，再也不用new来new去了。</p><h1 id="如何装配Bean？"><a href="#如何装配Bean？" class="headerlink" title="如何装配Bean？"></a>如何装配Bean？</h1><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="配置扫描路径"><a href="#配置扫描路径" class="headerlink" title="配置扫描路径"></a>配置扫描路径</h3><p>Spring提供了两种方式配置扫描路径，二选一即可。</p><ol><li>添加一个Java配置类<br>@ComponentScan可配置扫描路径，如@ComponentScan(“com.xxx”)。如果没有指定扫描路径，则默认扫描配置类所在的包，以及这个包下所有的子包。</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line">public class XxxConfiguration&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置xml<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"com.xxx"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置组件"><a href="#配置组件" class="headerlink" title="配置组件"></a>配置组件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动装配-1"><a href="#自动装配-1" class="headerlink" title="自动装配"></a>自动装配</h3><ol><li><p>成员变量注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FlyBehavior flyBehavior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(FlyBehavior flyBehavior)</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FlyBehavior flyBehavior;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyBehavior=flyBehavior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="基于Java的显式配置"><a href="#基于Java的显式配置" class="headerlink" title="基于Java的显式配置"></a>基于Java的显式配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FlyBehavior <span class="title">flyBehavior</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FlyBehavior();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Duck <span class="title">duck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Duck(flyBehavior());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Duck <span class="title">duck2</span><span class="params">(FlyBehavior flyBehavior)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Duck(flyBehavior);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于xml的显式配置"><a href="#基于xml的显式配置" class="headerlink" title="基于xml的显式配置"></a>基于xml的显式配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-DI是什么？&quot;&gt;&lt;a href=&quot;#Spring-DI是什么？&quot; class=&quot;headerlink&quot; title=&quot;Spring DI是什么？&quot;&gt;&lt;/a&gt;Spring DI是什么？&lt;/h1&gt;&lt;p&gt;DI，Dependency Injection，依赖
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Mosh安装教程</title>
    <link href="http://yoursite.com/2019/08/20/Linux-Mosh/"/>
    <id>http://yoursite.com/2019/08/20/Linux-Mosh/</id>
    <published>2019-08-20T11:34:40.000Z</published>
    <updated>2019-09-18T14:30:10.579Z</updated>
    
    <content type="html"><![CDATA[<p>Mosh，又名Mobile Shell，是交互式终端ssh的替代品。</p><p>与ssh相比，mosh的优势如下：</p><ul><li>在wifi与蜂窝数据间任意切换网络，mosh连接不受影响。</li><li>永远保持连接。计算机随时可以休眠，重新唤醒后，mosh连接完好无损， 除非你手动把进程kill掉。 </li><li>无网络延迟。在你打字的时候，ssh会等待服务器的响应。而mosh正好相反，不管是在输入、删除还是编辑行，mosh都会即时响应，让你有种丝般顺滑的感觉。</li></ul><h2 id="mosh运行原理"><a href="#mosh运行原理" class="headerlink" title="mosh运行原理"></a>mosh运行原理</h2><p>mosh包含两个程序，mosh-client和mosh-server。客户端与服务端都需要安装mosh，但不需要手动启动mosh-client或者mosh-server，因为每次使用mosh，这两个程序都是自动启动的。</p><p><strong><em>默认情况下，mosh会通过ssh连接到服务器，然后在服务端启动mosh-server。接着他关闭ssh连接，在客户端启动mosh-client并通过UDP连接上服务器。</em></strong></p><p>之后这个连接一直存在，用户可以通过mosh做以前ssh能做的一切操作。除非mosh-client被kill掉，这个连接会一直保持，不管网络掉线还是客户端异常。</p><p>ps. mosh使用的是60000到61000的端口。</p><h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>ps. 本文只针对CentOS系统，其他系统的安装请参考<a href="https://mosh.org/" target="_blank" rel="noopener">mosh官网</a></p><p>CentOS下，最快的安装方式是使用yum。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mosh</span><br></pre></td></tr></table></figure><p><img src="/images/Linux-Mosh/install-mosh-failed.jpg" alt><br>如果提示无法匹配，那么你需要扩展yum源，安装epel库。</p><h3 id="扩展yum源"><a href="#扩展yum源" class="headerlink" title="扩展yum源"></a>扩展yum源</h3><ol><li><p>首先，确认你的CentOS版本。不同系统版本对应的epel库不一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><p><img src="/images/Linux-Mosh/sys-version.jpg" alt></p></li><li><p>安装epel库。笔者的操作系统是CentOS 7，所以需执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br></pre></td></tr></table></figure><p>其他版本的CentOS系统可在<a href="https://fedoraproject.org/wiki/EPEL" target="_blank" rel="noopener">EPEL wiki</a>获取到相应命令。</p></li><li><p>启用epel库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用epel库</span></span><br><span class="line">yum-config-manager --<span class="built_in">enable</span> epel</span><br><span class="line"><span class="comment"># 刷新仓库缓存</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure></li><li><p>查看已启用的仓库列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure><p><img src="/images/Linux-Mosh/yum-repolist.jpg" alt></p></li><li><p>现在可以安装mosh啦，安装后无需手动启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mosh</span><br></pre></td></tr></table></figure><p><img src="/images/Linux-Mosh/install-mosh.jpg" alt><br>安装成功，现在去客户端尝试连接吧～</p></li></ol><h2 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h2><ol><li><p>如果你没有修改过ssh的端口，只需在客户端执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mosh root@203.109.86.12</span><br></pre></td></tr></table></figure></li><li><p>如果已修改ssh端口，则需通过-P指定ssh的端口（注意-P是大写哦～(｡ì _ í｡)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mosh -P 29806 root@203.109.86.12</span><br></pre></td></tr></table></figure></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>mosh也并不全是优点，他有个bug，输出超过一屏时，只显示最后一屏的内容，不支持回滚。所以需要查看全部输出时，可在命令后加上”| less”来翻页查看。</p><p>不过这个问题跟永不掉线和丝般顺滑比起来，真的无伤大雅了。</p><p>听说这个问题会在新版本修复，敬请期待吧。。</p><p>最后的最后，推荐一个app呀，ios的Blink，可以连接服务器，而且支持mosh哟，每次mosh连上服务器后，不管ipad待机多久，都不用担心掉线，随时打开随时用，感觉真的棒极啦～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mosh，又名Mobile Shell，是交互式终端ssh的替代品。&lt;/p&gt;
&lt;p&gt;与ssh相比，mosh的优势如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在wifi与蜂窝数据间任意切换网络，mosh连接不受影响。&lt;/li&gt;
&lt;li&gt;永远保持连接。计算机随时可以休眠，重新唤醒后，mo
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="mosh" scheme="http://yoursite.com/tags/mosh/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
</feed>
